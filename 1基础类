## 页面布局的5种方法
### 1.每个解决方案的优缺点
    flex布局和table布局比较适合
### 2.它们之间的比较，把高度去掉，哪种方法不适用
### 3.变通：上下高度固定，中间自适应

## css盒模型
### 1.margin padding border width height content
### 2.基本概念： 标准模型+IE模型
### 3.标准模型和IE模型的区别
     宽度和高度计算的不同: 标准模型的宽度是content, IE模型包含border和padding
     如何设置这两种模型: box-sizing:border-box; box-sizing:content-box(默认)
     js如何设置获取盒模型对应的宽和高：
        dom.style.width/height;(只能取内联模式的宽和高)
        dom.currentStyle.width/height;(渲染以后的宽和高，准确但只有IE支持)
        window.getComputedStyle(dom).width/height; (最好)
        dom.getBoundingClientRect().width/height; (可以，一般用来获取定位的)
     根据盒模型解释边距重叠
        父子边距重叠
        兄弟元素边距重叠
     BFC(边距重叠解决方案):块级、格式化、上下文
        BFC原理：1.元素边距会发生重叠；2.BFC区域不会与浮动元素的dom重叠
                3.BFC是独立的容器，外面与里面的元素互不影响
                4.计算BFC高度，浮动元素也会参与计算
        如何创建BFC：1.float不为none;
                   2.overflow不为visible
                   3.position值不为static和relative
                   4.display:inline-block table table-cell等
        父子边距：给父元素加overflow:hidden相当于创建了BFC
     IFC：内联、格式化、上下文

## DOM事件
    1.基本概念：DOM事件的级别，DOM1没有设置事件相关的内容
        DOM0
            element.onclick=function(){}
        DOM2
            element.addEventListener('click',function(){},false) // false表示阻止冒泡
        DOM3 增加了许多鼠标事件、键盘事件
            element.addEventListener('keyup',function(){},false)
    2.DOM事件模型（冒泡和捕获）
    3.DOM事件流
        捕获：=> 目标阶段（按钮） 从点击开始到达目标元素
        冒泡：<= 目标阶段（按钮） 事件触发后的事情

    4.DOM事件捕获的具体流程
        html节点：document.documentElement
        body节点：document.body
        流程：window => document => html => body => ... => 目标元素
        （冒泡的流程就是反过来）
    5.Event对象的常见应用
        event.preventDefault()
        event.stopPropagation()
        event.stopImmediatePropagation() // 事件优先级
        event.currentTarget 当前被绑定的元素
        event.target 当前被点击的元素
        e.currentTarget指的是注册了事件监听器的对象，而e.target指的是该对象里的子对象，也是触发这个事件的对象！
    6.自定义事件
        var eve=new Event('custom',{
             "bubbles" : true, // 是否冒泡
             "cancelable" : false, // 是否取消
             "composed" : false // 是否在阴影根之外
           });
        var eve=new CustomEvent('custom',{
           "detail" : {  //可携带额外的数据
             age : 18
           },
           "bubbles" : true,
           "cancelable" : false,
         });
        ev.addEventListener('custom',function(){
            console.log('custom')
        })
        ev.dispatchEvent(eve)

## 数据类型转换
    1.原始类型
        Boolean Null Undefined Number String Symbol
        (Object不属于原始类型）
    2.显式类型转换
        Number() String() Boolean()

        1) Number()
            数值 => 原来的值
            字符串 => 如果能被解析为数值，就转成数值，否则得到NaN, 空字符串转为0
                     Number('1a') = NaN
                     '' = 0
                     ' ' = 0
            布尔值 => true转成1，false转成0
            undefined => NaN
            null => 0
            Object => 先调用.valueOf(), 如果返回不是原始类型，再调用.toString(),如果还不是原始类型，报错
                                        如果是原始类型就调用Number()
        2) String() (没啥说的)
            true => 'true'
            undefined => 'undefined'
            null => 'null'
            Object => 先调用.toString(), 如果返回不是原始类型，再调用valueOf(),如果还不是原始类型，报错
                                        如果是原始类型就调用Number()
        3) Boolean()
            undefined null 0 -0 +0 NaN '' 全部返回false, 其它返回true
    3.隐式类型转换
        情景：四则运算、判断语句、Native调用（console.log, alert）
        好玩的运算：
            []+[] => ""
            {}+{} => "[object Object][object Object]"
            []+{} => "[object Object]"
            {}+[] => 0
            true+true => 2
            1+{a:1} => "1[object Object]"
        typeof:
            Undefined => 'undefined'
            Null => 'object'
            Symbol => 'symbol'
            Host object => 'Implementation-dependent'
            Function object => 'function'
            Any other object => 'object'
